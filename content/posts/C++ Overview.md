# C++ Overview
---
## 一、语法与特性

### Reference

> [How are references implemented internally?](https://stackoverflow.com/questions/3954764/how-are-references-implemented-internally)

C++ 区别于 C 语言的一大特性就是引用。相信很多人都听过“引用就是给变量取一个别名”这个说法，但请别忽视了前提 _just for convenience_。事实上引用的底层是用指针实现的，只有通过地址才能真正获取到变量的值。引用变量表现地就如同它是所引用变量的别名，它有几个关键的性质，不可修改引用对象（类似于 const pointer 的效果，注意不是 pointer to const）、不可拷贝、不可移动、获取不到其地址（它在栈中占用和指针同等大小的空间，存储的就是引用变量的地址）等。

在模板编程中，事情发生了变化，你可能希望容器中能存储引用而非实际的对象（避免昂贵的拷贝代价），却发现引用既不 copyable 也不 movable，于是 C++ 引入了 `std::reference_wrapper` 用于完成这件事。为此，你需要显式地使用 `std::ref` 来构造引用而非在函数传参时依靠左值或右值引用去捕获传入的实参。

#### 值类别

1. **左值（lvalue）：** 可以取地址的持久对象。
2. **右值（rvalue）：** 不能取地址的临时对象或纯右值。

   - **prvalue（pure value）：** 纯右值，临时对象或字面量。
   - **xvalue（expiring value）：** 将亡值，如返回局部对象的引用。

#### 非常量/常量引用

**非常量引用**（`T&`）：

只能绑定到左值。这是因为非常量引用允许修改其所引用的对象，而右值通常是临时的，不能被修改。

**常量引用** (`const T&`)：

可以绑定到左值和右值。由于常量引用保证不会通过该引用修改对象，因此它可以安全地引用临时对象（右值）。

#### 移动语义（Move Semantic）

在一些动态内存管理类（比如 std::vector）中，进行扩容时，将旧的内存内容复制到新开辟内存中的过程是无谓的，更好的方式是移动元素。

##### 右值引用

> 一个简单的判断标准是，`能对该表达式取地址吗 ? 左值表达式 : 右值表达式`
> [右值引用说明](https://www.cnblogs.com/qicosmos/p/4283455.html)

右值引用绑定到一个将亡值（将要销毁的元素），左值引用绑定到一个持久值。无论是左值引用还是右值引用，都是引用，只是能绑定到的值类型不同。（引用之间是可以进行类型转换的）

语法上的区别，左值引用：`&`，右值引用：`&&`。

`std::move` 将左值表达式转换为右值表达式（从效果上看）。对一个对象调用 `move` 后，不能再使用该对象的值。

**通用引用**

语法：T&& (T 是模板类型)

在模板编程中，通用引用配合 `std::forward` 可以实现完美转发，即将传入的左值转换为左值引用，传入的右值转换为右值引用，省去了函数重载的工夫。

**完美转发**

保持值类别，本质上是移动语义的衍生物。

### STL

#### container

##### std::array

> [https://en.cppreference.com/w/cpp/container/array](https://en.cppreference.com/w/cpp/container/array)

`std::array` 是封装固定大小数组的容器。

此容器是一个聚合类型，其语义等同于保有一个 C 风格数组 T[N] 作为其唯一非静态数据成员的结构体。

实现 `std::array` 只需要按照规定设置别名，以及提供访问自己保有的数组的成员函数。它的构造函数和析构函数都是隐式声明的。

**错误：**

我过去的一个误区是自以为 array 使用了动态内存分配。

### Class

#### 生命周期

成员变量的初始化发生在进入构造函数体之前，在 C++ 中，当创建一个对象实例时，首先会为该对象分配内存，并且按照类定义中的顺序调用每个成员变量的构造函数来初始化这些成员。

如果某个成员变量**没有默认构造函数**，则必须通过构造函数的初始化列表提供必要的参数来进行初始化。

构造函数体内只能进行赋值操作。

初始化列表是在对象创建时用于初始化成员变量和基类部分的特定位置。它出现在构造函数体执行之前，并且是唯一能够初始化某些类型的成员变量的地方。

> 某些类型：
>
> - 没有默认构造函数的成员变量。
> - `const` 成员变量。
> - 引用类型的成员变量。

#### 成员控制函数

> 构造、拷贝、析构

- **默认构造函数**
- **拷贝构造函数** `MyClass(const MyClass&);`
- **拷贝赋值运算符** `ClassName& operator=(const ClassName& other);`
- **移动构造函数** `MyClass(const MyClass&&);`
  
  移动构造函数不分配任何新内存，它使用的仍然是源对象的内存区域，只是它会将源对象的成员指针改为空指针，使得源对象失去对原先内存的访问能力。该函数往往被声明为不抛出异常（在函数声明的参数列表后加上 `noexcept` 进行修饰）。
- **移动赋值运算符**

  同样声明为 `noexcept`。

- **析构函数**
  编译器生成的默认析构函数，其行为取决于成员变量的类型，对于类类型的变量，会调用其析构函数；对于内置类型，则什么也不需要做。
  基本原则：需要析构函数的类也需要拷贝构造和拷贝赋值
  > 在类的定义中实现的成员函数自动被声明为 `inline`（类外实现的成员函数就不被声明为 `inline`），但实际是否进行内联还是得看编译器。
  > 如果自定义析构函数，对象销毁时的析构是由编译器自动管理的。编译器首先会调用你自定义的析构函数，然后自动调用该对象的所有非静态成员变量的析构函数，如果该类是从其他类派生的，则会接着调用基类的析构函数。
  >

#### 类的行为

**值**

类表现得像一个值，比如 `std::string`，在赋值时，新的对象有自己独立的一份拷贝。

**指针**

类表现得像一个指针

#### 类的修饰

##### 函数删除修饰

> 原则：当一个类有数据成员不能被默认构造、拷贝、复制或销毁，则对应的成员函数被定义为删除的。

在函数的参数列表后加上 `=delete` 表明该函数是被删除的。

```cpp
struct NoCopy {
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy& operator=(const NoCopy&) = delete;
}
```

##### 引用限定符修饰

从语法上来说，对右值进行赋值不会报错，但这实际上并非我们期望的现象。

可以在成员函数的参数列表后加上 `&` 进行修饰，使得该成员函数只能被用于左值；类似的，加上 `&&` 修饰使得该成员函数只能被用于右值。

##### 常量修饰

可以在成员函数的参数列表后加上 `const` 进行修饰，表示该成员函数不会修改成员变量。

##### 无异常修饰

可以在成员函数的参数列表后加上 `noexcept` 进行修饰，表示该成员函数不会抛出异常。

#### Struct VS Class

> 这里的内容大致上是正确的，但是肯定有我疏忽的细节，待日后对底层了解地更透彻后回来再做修改。

##### 区别

在 C++ 中，结构体和 C 语言中的结构体大有不同，它就是类，只是默认的成员访问权限和继承权限有所不同。

`struct` 默认是以 `public` 方式声明成员变量及函数的，所以对于一些简单的结构定义，使用 `struct` 是个更加明智的选择。

`class` 默认是以 `private` 方式声明成员变量及函数的，对于更加复杂的访问控制，还是用 `class` 更合适。

##### 共通之处——内存结构

在内存中，对于一个类对象，计算机将存储声明的成员变量，但是声明的函数却并不会存储在对象中。因为类同时也是一个命名空间（namespace），因此，我们可以粗略认为其成员函数存储在对应的命名空间当中，但是成员函数会绑定到特定的对象上（我怀疑底层的实现和使用 `std::bind` 将 `this` 绑定到成员函数是类似的）。类似地，对于静态的在类中声明的函数和变量，你完全可以把这个类仅仅当作命名空间，这些静态量可以将其视为普通的与类无关的函数和变量，这也就是为什么在静态类函数中直接引用 `this` 是非法的。回到主题，那难道 C++ 中 `class` 的内存存储方式就和 C 语言中一模一样吗？Yes and no.

当我们使用类继承时，在子类中重写父类中定义的虚函数，编译器需要通过一个虚函数表来查找对应的函数，因此如果我们重载了虚函数，对象的内存中还会额外存储这张虚表。

### Function

> [lambda，std::function 以及 std:bind](https://paul.pub/cpp-lambda-function-bind/)

仿函数

函数对象

#### lambda 表达式

- [&] 以引用的方式捕获所有变量
- [=] 以复制的方式捕获所有变量
- [=, &foo] 以引用的方式捕获 foo 变量，但是以复制的方式捕获其他变量
- [bar] 以复制的方式捕获 bar 变量，不再捕获任何其他变量
- [this] 捕获 this 指针

#### 尾置返回类型

用于函数返回类型的自动推导，一般用于返回**类型比较复杂**，或者需要通过**模板参数（或其他表达式）来推导返回类型**的情况，通常会结合 `decltype` 一起使用。在函数声明的参数列表右侧添加 `->ReturnType` 来代表函数返回类型，并将通常放置函数返回类型的位置用 `auto` 替代。

后置的一个关键原因在于，使用模板参数来推导返回类型的前提是参数已被声明，如若前置，则会因使用未声明的标识符而编译错误。

### RAII

> - [RAII 机制运用](https://chensongpoixs.github.io/2018/12/20/C++%E4%B8%AD%E7%9A%84RAII%E6%9C%BA%E5%88%B6%E8%BF%90%E7%94%A8/#/)
> - [什么是 RAII](https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii)

RAII 全称为 Resource Acquisition Is Initialization（资源获取即初始化），这项技术的名称不足以反映出它的本质，更合适的称呼应当为 **Scope-Bound Resource Management**（范围绑定资源管理），旨在将资源的生命周期与其范围相绑定。具体来说，当从函数返回时，其中的局部变量被销毁，应当将其申请的资源（如果有）也释放。

智能指针是运用 RAII 机制的一个典例。

#### 智能指针

> 尽可能使用智能指针不代表可以滥用，对于可以当作局部变量来使用的资源，比如 mutex, cv 等，没有必要使用智能指针管理它们的生命周期，因为并没有进行内存的分配。

**shared_ptr** 与 **weak_ptr **的使用区别。

weak_ptr 不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的 shared_ptr（提升操作通过 lock()函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的 shared_ptr。在使用中，往往采取 parent->child 使用 shared_ptr，child->parent 使用 weak_ptr 的策略，用以打破循环引用。

##### Api 说明

`get()` 返回裸指针。

### const & constexpr

`const` 关键字主要用于声明不可修改的变量或对象。它告诉编译器该变量或对象在初始化后不能被修改。

`constexpr` 是 C++11 引入的关键字，表示“常量表达式”。它不仅表明一个变量或函数的结果是常量，还要求编译器在编译时计算出这个常量的值（如果可能的话）。

- `const` 声明只读
- `constexpr` 声明编译时常量

### IO

C++ iostream 的使用请参考

- [第 14 章 使用传统 iostream 库 (Sun Studio 12:C++ 用户指南)](https://docs.oracle.com/cd/E19205-01/820-1214/bkaki/index.html)
- [ios - Oracle Solaris Studio 12.4 Man Pages](https://docs.oracle.com/cd/E57201_01/html/E57229/ios-3cc4.html)

### Template

> [tutorial](https://github.com/wuye9036/CppTemplateTutorial)
> 由于篇幅限制，我将专门在另一个文档中记录模板的用法

模板是为了实现泛型编程，提高代码的复用性。

模板在声明时，除了模板参数以外，还可以声明具体类型的参数。与函数的关键区别就在于模板是编译时处理的，函数是运行时处理的。

#### 模板特化

##### 全特化

针对 `type` 类型做了专门的模板，因为 `type` 类型会比较特殊。比如当你创建一个 `printer` 类时，打印一些基本类型都没有问题，但是遇到指针类型时，你期望打印的是指针指向内存中的值而非指针本身的值，这就是一个需要全特化的应用场景。

```cpp
template <>
class MyClass<type>
```

##### 偏特化

当模板参数有多个时，将其中部分参数做特化处理，就称为偏特化。

```cpp
template <typename T, typename U>
class MyClass<T,U*>
{
    T a;
    U *b;
};
```

值得注意的是，模板在进行类型替换时仅仅替换声明的 typename，所以在使用特化参数时（本例中是指针），仍然需要加上指针声明符。

#### 模板折叠

#### 变参模板（Variadic Template）

#### SFINAE（Substitution Failure Is Not An Error）

只要有正确的候选，就无视替换失败的做法为 SFINAE。

`std::enable_if` 就是 SFINAE 的主要应用，它利用了替换非失败这一特性唯一地生成了一个函数实例。

#### 扮演的角色

从直觉上，函数模板似乎做着与函数重载类似的事。

函数重载的标准是，不同重载版本的函数声明之间能够被区分（即不产生二义性）。

```cpp
int cal(int a);
float cal(float b);
double cal(double a, double b);
```

我们尝试使用模板来进行重载：

```cpp
template <typename T> T cal(T a);
template <> int cal(int a);
template <> float cal(float a);
template <> double cal(double a, double b);    /* 不幸的是，模板要求特化后模板仍然保持与原型保持一致，即参数的数量 */
```

## 二、必要基础

### 编译链接

[编译链接的应用](https://iw0bxqi9l0n.feishu.cn/docx/KpXEdOoVNo782FxExvIc9A1sn1S)

## 三、规范与准则

### 尽量避免使用预处理器

### 尽可能使用 const

C++ 编译器中对于成员函数的 const 修饰使用 bitwise constness，即该成员函数不能修改对象中任意一个 bit，但是这种规范允许了一种“越狱”行为，成员函数是一个指针，该指针作为常量不会修改它所指向的地址，但是它指向地址中的内容允许被修改。成员函数指针指向的内容在逻辑上也被视为该对象的一部分，因此这违反了 logical constness。我们在编写程序时，总是该秉持 logical constness 的原则，const 函数不修改对象的逻辑状态。

`mutable` 可以释放掉 non-static 成员变量的 bitwise constness 约束，使得声明为 const 的函数可以修改这些变量。

### 对象使用前先初始化

构建函数优先使用成员初始列表（member initializtion list）

### 编译单元（translation unit）

产出单一目标文件（single object file）的源码，加上其所包含的头文件。

### 单例模式（Singleton）

C++ 对于“定义于不同的编译单元内的 non-local static 对象”的初始化相对次序并无明确定义，即我们在引用一个 `extern OBJ obj` 时无法保证它已经正确被初始化。而 `static` 对象会在函数被调用时被初始化，所以我们可以提供一个特殊的“构造函数”，返回一个单例，通过这个函数获取该对象实例。

### 显式拒绝编译器自动生成的函数

- 法一：将不需要的拷贝构造函数声明为 private
- 法二：将不需要的函数显式 delete

### 为多态基类声明 virtual 析构函数

如果通过父类指针指向一个子类对象，并且该父类的虚构函数声明为 non-virtual，那么在 delete 父类指针时仅仅会销毁父类对象所含成员占用的内存而遗漏子类对象所含成员额外占用的内存。

### 别让异常逃离析构函数

- 如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，要么不继续向外抛出，要么终止程序。

### 绝不在构造和析构过程中调用 virtual 函数

#### 引入

##### 重载与虚函数

函数重载实现的是编译时多态，重载要求函数签名不同；

虚函数用于实现运行时（动态）多态，即通过基类指针或引用可以调用派生类的具体实现，而不是基类虚函数的抽象实现。

##### 继承中的构造函数

如果子类的构造函数没有显式调用父类的构造函数，则编译器会自动调用父类的默认构造函数；

子类中如果要调用父类的带参构造函数，必须在初始化列表中显式指定。

### 问题

如果基类在其构造函数中调用了 virtual 函数，对基类构造函数来说，它会调用基类的 virtual 函数实现，而不会动态地调用当前派生类重写的 virtual 函数，这往往是使用者期望之外的，因此我们应当避免这种情形。

### 令 operator= 返回一个 reference to *this

赋值可以被写成连锁形式：

```cpp
int x, y, z;
x = y = z = 15;
```

`operator=` 请写成：

```cpp
Widget& operator=(const Widget& rhs)
{
    ...
    return *this;
}
```

## 四、参考

- [C++ 语言参考](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-language-reference?view=msvc-170)
- [《Effective Modern C++》](https://github.com/CnTransGroup/EffectiveModernCppChinese)
